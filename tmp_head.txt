<script setup lang="ts">
import { onMounted, onUnmounted, ref } from 'vue'
import * as THREE from 'three'

const container = ref<HTMLDivElement | null>(null)
let renderer: THREE.WebGLRenderer
let scene: THREE.Scene
let camera: THREE.PerspectiveCamera
let sphere: THREE.Mesh
let innerSphere: THREE.Mesh
let particles: THREE.Points
let movingLight: THREE.PointLight
let rimLight: THREE.DirectionalLight
let raf = 0
let startTime = 0
let halo1: THREE.Mesh | null = null
let halo2: THREE.Mesh | null = null
let halo3: THREE.Mesh | null = null

onMounted(() => {
  const el = container.value!
  
  // ?¿æ?å¼å°ºå¯¸è?ç®?  const updateSize = () => {
    const rect = el.getBoundingClientRect()
    const baseSize = Math.min(window.innerWidth, window.innerHeight)
    let size = baseSize * 0.6
    
    // ?‹æ??ªå?
    if (window.innerWidth <= 480) {
      size = Math.min(window.innerWidth - 32, window.innerHeight * 0.4)
    }
    // å¹³æ¿?ªå?
    else if (window.innerWidth <= 768) {
      size = Math.min(baseSize * 0.5, 400)
    }
    // æ¡Œæ??ªå?
    else {
      size = Math.min(baseSize * 0.4, 500)
    }
    
    return Math.max(200, size)
  }

  let currentSize = updateSize()

  // Renderer è¨­å?
  renderer = new THREE.WebGLRenderer({ 
    antialias: true, 
    alpha: true,
    powerPreference: "high-performance"
  })
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
  renderer.setSize(currentSize, currentSize)
  renderer.shadowMap.enabled = true
  renderer.shadowMap.type = THREE.PCFSoftShadowMap
  renderer.toneMapping = THREE.ACESFilmicToneMapping
  renderer.toneMappingExposure = 1.2
  el.appendChild(renderer.domElement)

  // Scene & Camera
  scene = new THREE.Scene()
  camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100)
  camera.position.set(0, 0, 8)

  // ä¸»è??ƒé? - ?»ç?è³ªæ?
  const sphereGeo = new THREE.SphereGeometry(2.2, 128, 128)
  const sphereMat = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(0.4, 0.7, 1.0),
    roughness: 0.05,
    metalness: 0.0,
    transmission: 0.95,
    thickness: 0.8,
    clearcoat: 1.0,
    clearcoatRoughness: 0.05,
    ior: 1.5,
    reflectivity: 0.9,
    iridescence: 0.3,
    iridescenceIOR: 1.3,
    iridescenceThicknessRange: [100, 800]
  })
  sphere = new THREE.Mesh(sphereGeo, sphereMat)
  sphere.castShadow = true
  sphere.receiveShadow = true
  scene.add(sphere)

  // ?§éƒ¨?ƒé? - ?¼å??¸å?
  const innerGeo = new THREE.SphereGeometry(1.6, 64, 64)
  const innerMat = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(1.0, 0.8, 0.9),
    emissive: new THREE.Color(0.15, 0.1, 0.25),
    roughness: 0.3,
    metalness: 0.1,
    transmission: 0.7,
    thickness: 0.5,
    opacity: 0.6,
    transparent: true
  })
  innerSphere = new THREE.Mesh(innerGeo, innerMat)
  scene.add(innerSphere)

  // ç²’å?ç³»çµ±
  const particleCount = 200
  const positions = new Float32Array(particleCount * 3)
  const colors = new Float32Array(particleCount * 3)
  const sizes = new Float32Array(particleCount)

  for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3
    const radius = 1.2 + Math.random() * 0.8
    const theta = Math.random() * Math.PI * 2
    const phi = Math.acos(2 * Math.random() - 1)
    
    positions[i3] = radius * Math.sin(phi) * Math.cos(theta)
    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta)
    positions[i3 + 2] = radius * Math.cos(phi)
    
    const colorIntensity = 0.5 + Math.random() * 0.5
    colors[i3] = 0.8 * colorIntensity
    colors[i3 + 1] = 0.9 * colorIntensity
    colors[i3 + 2] = 1.0 * colorIntensity
    
    sizes[i] = Math.random() * 3 + 1
  }

  const particleGeo = new THREE.BufferGeometry()
  particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3))
  particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3))
  particleGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1))

  const particleMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 }
    },
    vertexShader: `
      attribute float size;
      attribute vec3 color;
      varying vec3 vColor;
      varying float vAlpha;
      uniform float time;
      
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
        
        float pulse = sin(time + position.x * 10.0) * 0.5 + 0.5;
        vAlpha = 0.3 + pulse * 0.4;
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      varying float vAlpha;
      
      void main() {
        float dist = distance(gl_PointCoord, vec2(0.5));
        if (dist > 0.5) discard;
        
        float alpha = (1.0 - dist * 2.0) * vAlpha;
        gl_FragColor = vec4(vColor, alpha);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    vertexColors: true
  })

  particles = new THREE.Points(particleGeo, particleMat)
  scene.add(particles)

  // å¤šå±¤?‰æ??ˆæ?
  const createHalo = (radius: number, color: number, opacity: number) => {
    const haloGeo = new THREE.SphereGeometry(radius, 64, 64)
    const haloMat = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.0,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    })
    return new THREE.Mesh(haloGeo, haloMat)
  }

  halo1 = createHalo(2.4, 0x66aaff, 0.15)
  halo2 = createHalo(2.7, 0xaa77ff, 0.12)
  halo3 = createHalo(3.1, 0xff88dd, 0.08)
  
  scene.add(halo1)
  scene.add(halo2)
  scene.add(halo3)

  // ?‰ç…§ç³»çµ±
  const ambientLight = new THREE.AmbientLight(0x404080, 0.3)
  scene.add(ambientLight)

  const hemisphereLight = new THREE.HemisphereLight(0x7799ff, 0xffddaa, 0.4)
  scene.add(hemisphereLight)

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.2)
  keyLight.position.set(4, 6, 4)
  keyLight.castShadow = true
  keyLight.shadow.mapSize.width = 2048
  keyLight.shadow.mapSize.height = 2048
  keyLight.shadow.camera.near = 0.5
  keyLight.shadow.camera.far = 20
  keyLight.shadow.camera.left = -10
  keyLight.shadow.camera.right = 10
  keyLight.shadow.camera.top = 10
  keyLight.shadow.camera.bottom = -10
